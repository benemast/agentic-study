#!/usr/bin/env python3
"""
Automated migration from SERIAL to GENERATED AS IDENTITY
Run from backend directory: python migrate_to_identity.py
"""

import os
import sys
from pathlib import Path
from sqlalchemy import create_engine, text
from dotenv import load_dotenv

# Load .env from backend directory (parent of migrate/)
env_path = Path(__file__).parent.parent / '.env'
load_dotenv(env_path)

def migrate_serial_to_identity():
    """
    Safely migrate all SERIAL columns to GENERATED AS IDENTITY
    """
    
    DATABASE_URL = os.getenv("DATABASE_URL")
    if not DATABASE_URL:
        print("‚ùå DATABASE_URL not found in environment")
        return False
    
    print("=" * 60)
    print("SERIAL ‚Üí IDENTITY Migration Script")
    print("=" * 60)
    
    engine = create_engine(DATABASE_URL)
    
    # List of tables to migrate
    tables_to_migrate = [
        'sessions',
        'chat_messages',
        'chat_conversations',
        'chat_analytics',
        'demographics',
        'interactions',
        'session_errors'  # Added missing table
    ]
    
    try:
        with engine.begin() as conn:  # Changed from connect() to begin()
            print("\nüìã Step 1: Discovering SERIAL columns...")
            
            # Find all SERIAL columns
            result = conn.execute(text("""
                SELECT 
                    c.table_name,
                    c.column_name,
                    pg_get_serial_sequence('public.' || c.table_name, c.column_name) as sequence_name
                FROM information_schema.columns c
                WHERE c.table_schema = 'public'
                  AND c.column_default LIKE 'nextval%'
                  AND c.table_name IN :tables
                ORDER BY c.table_name
            """), {"tables": tuple(tables_to_migrate)})
            
            serial_columns = result.fetchall()
            
            if not serial_columns:
                print("‚úÖ No SERIAL columns found. Already using IDENTITY?")
                return True
            
            print(f"\nüìä Found {len(serial_columns)} SERIAL columns:")
            for row in serial_columns:
                print(f"   - {row.table_name}.{row.column_name} (seq: {row.sequence_name})")
            
            # Confirm migration
            print("\n" + "=" * 60)
            confirm = input("‚ö†Ô∏è  Proceed with migration? This is SAFE but creates a transaction. (yes/no): ")
            
            if confirm.lower() != 'yes':
                print("‚ùå Migration cancelled")
                return False
            
            print("\nüîÑ Step 2: Migrating columns...")
            
            # Migrate each column
            for row in serial_columns:
                table_name = row.table_name
                column_name = row.column_name
                sequence_name = row.sequence_name
                
                print(f"\n   Migrating {table_name}.{column_name}...")
                
                try:
                    # Get current max ID to preserve sequence
                    max_id_result = conn.execute(
                        text(f"SELECT COALESCE(MAX({column_name}), 0) FROM {table_name}")
                    )
                    max_id = max_id_result.scalar()
                    print(f"      Current max ID: {max_id}")
                    
                    # Set sequence to current max (minimum 1 for setval)
                    if sequence_name:
                        setval_value = max(1, max_id)
                        conn.execute(text(f"SELECT setval('{sequence_name}', {setval_value})"))
                    
                    # Convert to IDENTITY
                    conn.execute(text(f"""
                        ALTER TABLE {table_name}
                        ALTER COLUMN {column_name} DROP DEFAULT,
                        ALTER COLUMN {column_name} ADD GENERATED BY DEFAULT AS IDENTITY
                    """))
                    
                    print(f"      ‚úÖ {table_name}.{column_name} migrated successfully")
                    
                except Exception as e:
                    print(f"      ‚ùå Failed to migrate {table_name}.{column_name}: {e}")
                    raise
            
            print("\n‚úÖ Step 3: Verifying migration...")
            
            # Verify all columns are now IDENTITY
            verify_result = conn.execute(text("""
                SELECT 
                    table_name,
                    column_name,
                    is_identity,
                    identity_generation
                FROM information_schema.columns
                WHERE table_schema = 'public'
                  AND is_identity = 'YES'
                  AND table_name IN :tables
                ORDER BY table_name
            """), {"tables": tuple(tables_to_migrate)})
            
            identity_columns = verify_result.fetchall()
            
            print(f"\nüìä Identity columns after migration:")
            for row in identity_columns:
                print(f"   ‚úÖ {row.table_name}.{row.column_name} ‚Üí "
                      f"GENERATED {row.identity_generation} AS IDENTITY")
            
            print("\n" + "=" * 60)
            print("‚úÖ Migration completed successfully!")
            print("=" * 60)
            print("\nüìù Notes:")
            print("   - All existing data preserved")
            print("   - Auto-increment continues from current max ID")
            print("   - Old SERIAL sequences may still exist (harmless)")
            print("   - You can now restart your application")
            
            return True
            
    except Exception as e:
        print(f"\n‚ùå Migration failed: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = migrate_serial_to_identity()
    exit(0 if success else 1)